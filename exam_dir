import os
import sys
import threading
import av
import time
import pyaudio
import glob
from PySide6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, 
                              QWidget, QTextEdit, QLineEdit, QPushButton, QLabel,
                              QFileDialog, QMessageBox, QScrollArea)
from PySide6.QtCore import Qt, QThread, Signal, QTimer
from PySide6.QtGui import QFont, QPalette, QColor

if getattr(sys, 'frozen', False):
    qt_plugins_path = os.path.join(sys._MEIPASS, "PySide6", "plugins")
    os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path

class SpellingApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.words = []
        self.current_index = 0
        self.error_count = 0
        self.max_errors = 3
        self.is_playing = False
        self.audio_thread = None
        self.pyaudio_instance = None
        self.is_completed = False
        self.wrong_words = []
        self.current_folder = ""
        
        self.init_ui()
        self.log("è¯·é€‰æ‹©åŒ…å«MP3æ–‡ä»¶çš„æ–‡ä»¶å¤¹å¼€å§‹ç»ƒä¹ ")
        
    def init_ui(self):
        """åˆå§‹åŒ–UI"""
        self.setWindowTitle("å•è¯æ‹¼å†™ç»ƒä¹  - æš—é»‘æ¨¡å¼")
        self.setGeometry(100, 100, 850, 650)
        
        self.set_dark_theme()
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        layout = QVBoxLayout(central_widget)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 20, 20, 20)
        
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(QFont("Consolas", 14))
        layout.addWidget(self.console)
        
        input_layout = QHBoxLayout()
        input_label = QLabel(">")
        input_label.setFixedWidth(40)
        input_label.setFont(QFont("Consolas", 16))
        
        self.entry = QLineEdit()
        self.entry.setFont(QFont("Consolas", 16))
        self.entry.returnPressed.connect(self.check_spelling)
        
        input_layout.addWidget(input_label)
        input_layout.addWidget(self.entry)
        layout.addLayout(input_layout)
        
        button_layout = QHBoxLayout()
        
        self.select_btn = QPushButton("é€‰æ‹©æ–‡ä»¶å¤¹")
        self.select_btn.setFont(QFont("Microsoft YaHei", 14))
        self.select_btn.clicked.connect(self.select_folder)
        
        self.replay_btn = QPushButton("é‡æ–°æ’­æ”¾")
        self.replay_btn.setFont(QFont("Microsoft YaHei", 14))
        self.replay_btn.clicked.connect(self.replay_current)
        
        self.restart_btn = QPushButton("å†æ¥ä¸€æ¬¡")
        self.restart_btn.setFont(QFont("Microsoft YaHei", 14))
        self.restart_btn.clicked.connect(self.restart_practice)
        self.restart_btn.setVisible(False)
        
        self.copy_btn = QPushButton("å¤åˆ¶é”™è¯")
        self.copy_btn.setFont(QFont("Microsoft YaHei", 14))
        self.copy_btn.clicked.connect(self.copy_wrong_words)
        self.copy_btn.setVisible(False)
        
        self.quit_btn = QPushButton("é€€å‡º")
        self.quit_btn.setFont(QFont("Microsoft YaHei", 14))
        self.quit_btn.clicked.connect(self.cleanup_and_quit)
        
        button_layout.addWidget(self.select_btn)
        button_layout.addWidget(self.replay_btn)
        button_layout.addWidget(self.restart_btn)
        button_layout.addWidget(self.copy_btn)
        button_layout.addWidget(self.quit_btn)
        button_layout.addStretch()
        
        layout.addLayout(button_layout)
        
        self.apply_styles()
        QTimer.singleShot(100, self.center_window)
        
    def center_window(self):
        screen = QApplication.primaryScreen().availableGeometry()
        window_size = self.frameGeometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)
        
    def set_dark_theme(self):
        dark_palette = QPalette()
        dark_palette.setColor(QPalette.Window, QColor(30, 30, 30))
        dark_palette.setColor(QPalette.WindowText, Qt.white)
        dark_palette.setColor(QPalette.Base, QColor(25, 25, 25))
        dark_palette.setColor(QPalette.AlternateBase, QColor(30, 30, 30))
        dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
        dark_palette.setColor(QPalette.ToolTipText, Qt.white)
        dark_palette.setColor(QPalette.Text, Qt.white)
        dark_palette.setColor(QPalette.Button, QColor(60, 60, 60))
        dark_palette.setColor(QPalette.ButtonText, Qt.white)
        dark_palette.setColor(QPalette.BrightText, Qt.red)
        dark_palette.setColor(QPalette.Link, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.HighlightedText, Qt.black)
        self.setPalette(dark_palette)
        
    def apply_styles(self):
        style = """
        QPushButton {
            background-color: #3c3c3c;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            min-width: 120px;
        }
        QPushButton:hover {
            background-color: #4c4c4c;
        }
        QPushButton:pressed {
            background-color: #2c2c2c;
        }
        QLineEdit {
            background-color: #2d2d2d;
            color: white;
            border: 1px solid #555;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
        }
        QTextEdit {
            background-color: #1e1e1e;
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
        }
        QLabel {
            color: cyan;
            font-size: 16px;
        }
        """
        self.setStyleSheet(style)
        
    def log(self, message, color="white"):
        self.console.append(message)
        scrollbar = self.console.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def ensure_audio_initialized(self):
        if self.pyaudio_instance is None:
            try:
                self.pyaudio_instance = pyaudio.PyAudio()
                return True
            except Exception as e:
                self.log("âŒ éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥ï¼Œå°†æ— æ³•æ’­æ”¾å£°éŸ³")
                return False
        return True
        
    def play_audio_thread(self, file_path):
        try:
            self.is_playing = True
            container = av.open(file_path)
            audio_stream = container.streams.audio[0]
            sample_rate = audio_stream.sample_rate
            channels = audio_stream.channels
            
            p = self.pyaudio_instance
            stream = p.open(
                format=pyaudio.paInt16,
                channels=channels,
                rate=sample_rate,
                output=True,
                frames_per_buffer=4096
            )
            
            for frame in container.decode(audio_stream):
                if not self.is_playing:
                    break
                audio_data = frame.to_ndarray()
                if audio_data.dtype != 'int16':
                    audio_data = (audio_data * 32767).astype('int16')
                stream.write(audio_data.tobytes())
                
            stream.stop_stream()
            stream.close()
            container.close()
            
        except Exception as e:
            self.log(f"âŒ æ’­æ”¾é”™è¯¯: {str(e)}")
        finally:
            self.is_playing = False
        
    def play_audio(self, file_path):
        if not os.path.exists(file_path):
            self.log(f"âŒ æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
            return False
            
        if self.is_playing:
            self.stop_audio()
            time.sleep(0.1)
            
        if not self.ensure_audio_initialized():
            return False
            
        self.audio_thread = threading.Thread(target=self.play_audio_thread, args=(file_path,))
        self.audio_thread.daemon = True
        self.audio_thread.start()
        return True
        
    def stop_audio(self):
        self.is_playing = False
        if self.audio_thread and self.audio_thread.is_alive():
            self.audio_thread.join(timeout=1.0)
        
    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "é€‰æ‹©åŒ…å«MP3æ–‡ä»¶çš„æ–‡ä»¶å¤¹")
        if folder:
            self.current_folder = folder
            self.load_words(folder)
            
    def load_words(self, folder):
        self.words = []
        self.is_completed = False
        self.wrong_words = []
        try:
            # ä½¿ç”¨é›†åˆå»é‡ï¼Œé¿å…é‡å¤æ–‡ä»¶
            mp3_files = set()
            mp3_files.update(glob.glob(os.path.join(folder, "*.mp3")))
            mp3_files.update(glob.glob(os.path.join(folder, "*.MP3")))
            
            for file_path in mp3_files:
                word = os.path.splitext(os.path.basename(file_path))[0]
                self.words.append({
                    'word': word,
                    'path': file_path
                })
            
            self.words.sort(key=lambda x: x['word'].lower())
            
            if self.words:
                self.log(f"âœ… å·²åŠ è½½ {len(self.words)} ä¸ªå•è¯")
                self.current_index = 0
                self.error_count = 0
                self.hide_completion_buttons()
                self.play_current_word()
            else:
                self.log("âŒ æœªæ‰¾åˆ°MP3æ–‡ä»¶")
                
        except Exception as e:
            self.log(f"âŒ åŠ è½½æ–‡ä»¶å¤¹æ—¶å‡ºé”™: {str(e)}")
            
    def play_current_word(self):
        """æ’­æ”¾å½“å‰å•è¯çš„å‘éŸ³"""
        if not self.is_completed and self.current_index < len(self.words):
            word_data = self.words[self.current_index]
            self.log(f"ğŸ”Š æ’­æ”¾ç¬¬ {self.current_index + 1}/{len(self.words)} ä¸ªå•è¯...")
            self.play_audio(word_data['path'])
                
    def replay_current(self):
        """é‡æ–°æ’­æ”¾å½“å‰å•è¯"""
        if not self.is_completed and self.current_index < len(self.words):
            self.stop_audio()
            self.play_current_word()
            
    def check_spelling(self):
        """æ£€æŸ¥æ‹¼å†™"""
        if self.is_completed:
            return
            
        user_input = self.entry.text().strip()
        if not user_input or not self.words:
            return
            
        self.entry.clear()
        self.log(f"> {user_input}")
        
        current_word = self.words[self.current_index]['word']
        
        if user_input.lower() == current_word.lower():
            self.log("âœ… æ‹¼å†™æ­£ç¡®ï¼")
            self.current_index += 1
            self.error_count = 0
            
            if self.current_index < len(self.words):
                self.play_current_word()
            else:
                self.complete_practice()
        else:
            self.error_count += 1
            if self.error_count >= self.max_errors:
                self.log(f"âŒ å·²è¿ç»­{self.error_count}æ¬¡é”™è¯¯")
                self.log(f"ğŸ’¡ æ­£ç¡®ç­”æ¡ˆ: {current_word}")
                self.wrong_words.append(current_word)
                self.current_index += 1
                self.error_count = 0
                
                if self.current_index < len(self.words):
                    self.play_current_word()
                else:
                    self.complete_practice()
            else:
                self.log(f"âŒ æ‹¼å†™é”™è¯¯ï¼ˆç¬¬{self.error_count}æ¬¡ï¼‰ï¼Œè¯·é‡æ–°å°è¯•")
                self.replay_current()
                
    def complete_practice(self):
        self.is_completed = True
        self.log("ğŸ‰ æ‰€æœ‰å•è¯ç»ƒä¹ å®Œæˆï¼")
        
        if self.wrong_words:
            self.log("\nğŸ“ æœ€ç»ˆç­”é”™çš„å•è¯ï¼š")
            for i, word in enumerate(self.wrong_words, 1):
                self.log(f"  {i}. {word}")
            self.log(f"\næ€»å…±ç­”é”™ {len(self.wrong_words)} ä¸ªå•è¯")
        else:
            self.log("ğŸŠ å¤ªæ£’äº†ï¼æ‰€æœ‰å•è¯éƒ½ç­”å¯¹äº†ï¼")
            
        self.show_completion_buttons()
        
    def show_completion_buttons(self):
        self.restart_btn.setVisible(True)
        self.copy_btn.setVisible(True)
        
    def hide_completion_buttons(self):
        self.restart_btn.setVisible(False)
        self.copy_btn.setVisible(False)
        
    def restart_practice(self):
        if self.current_folder:
            self.load_words(self.current_folder)
            self.log("ğŸ”„ é‡æ–°å¼€å§‹ç»ƒä¹ ...")
        else:
            self.log("âŒ è¯·å…ˆé€‰æ‹©æ–‡ä»¶å¤¹")
            
    def copy_wrong_words(self):
        if self.wrong_words:
            wrong_words_text = "\n".join(self.wrong_words)
            QApplication.clipboard().setText(wrong_words_text)
            self.log("âœ… é”™è¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")
        else:
            self.log("ğŸ’¡ æ²¡æœ‰é”™è¯å¯å¤åˆ¶")
                
    def cleanup_and_quit(self):
        self.stop_audio()
        if self.pyaudio_instance:
            self.pyaudio_instance.terminate()
        QApplication.quit()
        
    def closeEvent(self, event):
        self.cleanup_and_quit()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SpellingApp()
    window.show()
    sys.exit(app.exec())
