import os
import sys
import threading
import av
import time
import pyaudio
import glob
from PySide6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, 
                              QWidget, QTextEdit, QLineEdit, QPushButton, QLabel,
                              QFileDialog, QMessageBox, QScrollArea)
from PySide6.QtCore import Qt, QThread, Signal, QTimer
from PySide6.QtGui import QFont, QPalette, QColor

if getattr(sys, 'frozen', False):
    qt_plugins_path = os.path.join(sys._MEIPASS, "PySide6", "plugins")
    os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path

class SpellingApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.words = []
        self.current_index = 0
        self.error_count = 0
        self.max_errors = 3
        self.is_playing = False
        self.audio_thread = None
        self.pyaudio_instance = None
        self.is_completed = False
        self.wrong_words = []
        self.current_folder = ""
        
        self.init_ui()
        self.log("请选择包含MP3文件的文件夹开始练习")
        
    def init_ui(self):
        """初始化UI"""
        self.setWindowTitle("单词拼写练习 - 暗黑模式")
        self.setGeometry(100, 100, 850, 650)
        
        self.set_dark_theme()
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        layout = QVBoxLayout(central_widget)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 20, 20, 20)
        
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(QFont("Consolas", 14))
        layout.addWidget(self.console)
        
        input_layout = QHBoxLayout()
        input_label = QLabel(">")
        input_label.setFixedWidth(40)
        input_label.setFont(QFont("Consolas", 16))
        
        self.entry = QLineEdit()
        self.entry.setFont(QFont("Consolas", 16))
        self.entry.returnPressed.connect(self.check_spelling)
        
        input_layout.addWidget(input_label)
        input_layout.addWidget(self.entry)
        layout.addLayout(input_layout)
        
        button_layout = QHBoxLayout()
        
        self.select_btn = QPushButton("选择文件夹")
        self.select_btn.setFont(QFont("Microsoft YaHei", 14))
        self.select_btn.clicked.connect(self.select_folder)
        
        self.replay_btn = QPushButton("重新播放")
        self.replay_btn.setFont(QFont("Microsoft YaHei", 14))
        self.replay_btn.clicked.connect(self.replay_current)
        
        self.restart_btn = QPushButton("再来一次")
        self.restart_btn.setFont(QFont("Microsoft YaHei", 14))
        self.restart_btn.clicked.connect(self.restart_practice)
        self.restart_btn.setVisible(False)
        
        self.copy_btn = QPushButton("复制错词")
        self.copy_btn.setFont(QFont("Microsoft YaHei", 14))
        self.copy_btn.clicked.connect(self.copy_wrong_words)
        self.copy_btn.setVisible(False)
        
        self.quit_btn = QPushButton("退出")
        self.quit_btn.setFont(QFont("Microsoft YaHei", 14))
        self.quit_btn.clicked.connect(self.cleanup_and_quit)
        
        button_layout.addWidget(self.select_btn)
        button_layout.addWidget(self.replay_btn)
        button_layout.addWidget(self.restart_btn)
        button_layout.addWidget(self.copy_btn)
        button_layout.addWidget(self.quit_btn)
        button_layout.addStretch()
        
        layout.addLayout(button_layout)
        
        self.apply_styles()
        QTimer.singleShot(100, self.center_window)
        
    def center_window(self):
        screen = QApplication.primaryScreen().availableGeometry()
        window_size = self.frameGeometry()
        x = (screen.width() - window_size.width()) // 2
        y = (screen.height() - window_size.height()) // 2
        self.move(x, y)
        
    def set_dark_theme(self):
        dark_palette = QPalette()
        dark_palette.setColor(QPalette.Window, QColor(30, 30, 30))
        dark_palette.setColor(QPalette.WindowText, Qt.white)
        dark_palette.setColor(QPalette.Base, QColor(25, 25, 25))
        dark_palette.setColor(QPalette.AlternateBase, QColor(30, 30, 30))
        dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
        dark_palette.setColor(QPalette.ToolTipText, Qt.white)
        dark_palette.setColor(QPalette.Text, Qt.white)
        dark_palette.setColor(QPalette.Button, QColor(60, 60, 60))
        dark_palette.setColor(QPalette.ButtonText, Qt.white)
        dark_palette.setColor(QPalette.BrightText, Qt.red)
        dark_palette.setColor(QPalette.Link, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.HighlightedText, Qt.black)
        self.setPalette(dark_palette)
        
    def apply_styles(self):
        style = """
        QPushButton {
            background-color: #3c3c3c;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            min-width: 120px;
        }
        QPushButton:hover {
            background-color: #4c4c4c;
        }
        QPushButton:pressed {
            background-color: #2c2c2c;
        }
        QLineEdit {
            background-color: #2d2d2d;
            color: white;
            border: 1px solid #555;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
        }
        QTextEdit {
            background-color: #1e1e1e;
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
        }
        QLabel {
            color: cyan;
            font-size: 16px;
        }
        """
        self.setStyleSheet(style)
        
    def log(self, message, color="white"):
        self.console.append(message)
        scrollbar = self.console.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def ensure_audio_initialized(self):
        if self.pyaudio_instance is None:
            try:
                self.pyaudio_instance = pyaudio.PyAudio()
                return True
            except Exception as e:
                self.log("❌ 音频初始化失败，将无法播放声音")
                return False
        return True
        
    def play_audio_thread(self, file_path):
        try:
            self.is_playing = True
            container = av.open(file_path)
            audio_stream = container.streams.audio[0]
            sample_rate = audio_stream.sample_rate
            channels = audio_stream.channels
            
            p = self.pyaudio_instance
            stream = p.open(
                format=pyaudio.paInt16,
                channels=channels,
                rate=sample_rate,
                output=True,
                frames_per_buffer=4096
            )
            
            for frame in container.decode(audio_stream):
                if not self.is_playing:
                    break
                audio_data = frame.to_ndarray()
                if audio_data.dtype != 'int16':
                    audio_data = (audio_data * 32767).astype('int16')
                stream.write(audio_data.tobytes())
                
            stream.stop_stream()
            stream.close()
            container.close()
            
        except Exception as e:
            self.log(f"❌ 播放错误: {str(e)}")
        finally:
            self.is_playing = False
        
    def play_audio(self, file_path):
        if not os.path.exists(file_path):
            self.log(f"❌ 文件不存在: {file_path}")
            return False
            
        if self.is_playing:
            self.stop_audio()
            time.sleep(0.1)
            
        if not self.ensure_audio_initialized():
            return False
            
        self.audio_thread = threading.Thread(target=self.play_audio_thread, args=(file_path,))
        self.audio_thread.daemon = True
        self.audio_thread.start()
        return True
        
    def stop_audio(self):
        self.is_playing = False
        if self.audio_thread and self.audio_thread.is_alive():
            self.audio_thread.join(timeout=1.0)
        
    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "选择包含MP3文件的文件夹")
        if folder:
            self.current_folder = folder
            self.load_words(folder)
            
    def load_words(self, folder):
        self.words = []
        self.is_completed = False
        self.wrong_words = []
        try:
            # 使用集合去重，避免重复文件
            mp3_files = set()
            mp3_files.update(glob.glob(os.path.join(folder, "*.mp3")))
            mp3_files.update(glob.glob(os.path.join(folder, "*.MP3")))
            
            for file_path in mp3_files:
                word = os.path.splitext(os.path.basename(file_path))[0]
                self.words.append({
                    'word': word,
                    'path': file_path
                })
            
            self.words.sort(key=lambda x: x['word'].lower())
            
            if self.words:
                self.log(f"✅ 已加载 {len(self.words)} 个单词")
                self.current_index = 0
                self.error_count = 0
                self.hide_completion_buttons()
                self.play_current_word()
            else:
                self.log("❌ 未找到MP3文件")
                
        except Exception as e:
            self.log(f"❌ 加载文件夹时出错: {str(e)}")
            
    def play_current_word(self):
        """播放当前单词的发音"""
        if not self.is_completed and self.current_index < len(self.words):
            word_data = self.words[self.current_index]
            self.log(f"🔊 播放第 {self.current_index + 1}/{len(self.words)} 个单词...")
            self.play_audio(word_data['path'])
                
    def replay_current(self):
        """重新播放当前单词"""
        if not self.is_completed and self.current_index < len(self.words):
            self.stop_audio()
            self.play_current_word()
            
    def check_spelling(self):
        """检查拼写"""
        if self.is_completed:
            return
            
        user_input = self.entry.text().strip()
        if not user_input or not self.words:
            return
            
        self.entry.clear()
        self.log(f"> {user_input}")
        
        current_word = self.words[self.current_index]['word']
        
        if user_input.lower() == current_word.lower():
            self.log("✅ 拼写正确！")
            self.current_index += 1
            self.error_count = 0
            
            if self.current_index < len(self.words):
                self.play_current_word()
            else:
                self.complete_practice()
        else:
            self.error_count += 1
            if self.error_count >= self.max_errors:
                self.log(f"❌ 已连续{self.error_count}次错误")
                self.log(f"💡 正确答案: {current_word}")
                self.wrong_words.append(current_word)
                self.current_index += 1
                self.error_count = 0
                
                if self.current_index < len(self.words):
                    self.play_current_word()
                else:
                    self.complete_practice()
            else:
                self.log(f"❌ 拼写错误（第{self.error_count}次），请重新尝试")
                self.replay_current()
                
    def complete_practice(self):
        self.is_completed = True
        self.log("🎉 所有单词练习完成！")
        
        if self.wrong_words:
            self.log("\n📝 最终答错的单词：")
            for i, word in enumerate(self.wrong_words, 1):
                self.log(f"  {i}. {word}")
            self.log(f"\n总共答错 {len(self.wrong_words)} 个单词")
        else:
            self.log("🎊 太棒了！所有单词都答对了！")
            
        self.show_completion_buttons()
        
    def show_completion_buttons(self):
        self.restart_btn.setVisible(True)
        self.copy_btn.setVisible(True)
        
    def hide_completion_buttons(self):
        self.restart_btn.setVisible(False)
        self.copy_btn.setVisible(False)
        
    def restart_practice(self):
        if self.current_folder:
            self.load_words(self.current_folder)
            self.log("🔄 重新开始练习...")
        else:
            self.log("❌ 请先选择文件夹")
            
    def copy_wrong_words(self):
        if self.wrong_words:
            wrong_words_text = "\n".join(self.wrong_words)
            QApplication.clipboard().setText(wrong_words_text)
            self.log("✅ 错词已复制到剪贴板")
        else:
            self.log("💡 没有错词可复制")
                
    def cleanup_and_quit(self):
        self.stop_audio()
        if self.pyaudio_instance:
            self.pyaudio_instance.terminate()
        QApplication.quit()
        
    def closeEvent(self, event):
        self.cleanup_and_quit()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SpellingApp()
    window.show()
    sys.exit(app.exec())
